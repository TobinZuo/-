```python
二分查找终极模板，减少细节错误，只用关注几个位置。nums是有序的数组。
l, r = 0, len(nums)  #1 
while l < r: #2
	mid = l + (r - l) // 2 #3
	if nums[mid] >= target: #4
		r = mid
	else:
		l = mid + 1
return l #5
```

1. 左闭右开区间。
2. 这里始终不取=，一套模板打天下，当r == l，即区间[l, l)没有元素时退出。某些题目可能要求与相邻元素比较，这里可以修改成l+k < r，即当剩余元素个数为k时退出。
3. 防止溢出，此时mid是上中位数，当l == r - 1时，mid == l，不会超出[l, r)的区间。
4. 当退出循环条件为l<r时，l更新不能为mid，会死循环。因为l与mid可能会相等。r与mid不会相等。
5. while l < r的好处是退出循环l==r，不用纠结返回l还是返回r。

二分查找原理简单，细节爆炸。因为注释的5个地方，修改任意一个地方，会要求其它地方也要相应的改变。最终的写法不只一种，好的组合写起来更简洁。但是我的目的是要求稳定且正确。

遇到问题，1，2，3全都不变，3根据区间要求有的题目可能要修改。基本只需要关注4和5。

4就是根据题目要求来更新搜索区间。我们这种写法需要注意两点，一是如果与mid+1进行比较，需要判断mid+1是否超过len(nums)，二是=应该放在if下还是else，这个需要具体分析。至于更新r=mid，l=mid+1不用修改。

5返回值可能在4部分已经找到返回了，但是有可能nums不存在需要找的值，根据题目进行修改，比如不存在时return -1。

这篇[知乎回答](https://www.zhihu.com/question/36132386/answer/530313852)写的比较好，可以参考。