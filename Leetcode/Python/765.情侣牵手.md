**题目链接**：https://leetcode-cn.com/problems/couples-holding-hands/

![image.png](https://pic.leetcode-cn.com/1612947031-XGPXVq-image.png)

![image.png](https://pic.leetcode-cn.com/1612947241-UULDLu-image.png)

![image.png](https://pic.leetcode-cn.com/1613227715-YEkSrV-image.png)

![image.png](https://pic.leetcode-cn.com/1613227521-VQEQVC-image.png)



**n对情侣，手拉手成环，至少需要n-1次交换**

证明：n= 1对情侣手拉手成环，ab，最少0次交换

n = 2对情侣手拉手成环，ac，bd，最少1次交换

n = 3对情侣手拉手成环，ac，be， df，最少2次交换

n = k(k>=3)对情侣手拉手成环，最少要k-1次交换

n = k+1对情侣手拉手成环，凑成一对，变成k对成环，需要k-1+1=k次交换

**n对情侣，手拉手成环，通过每次凑成一对的方式可以获得最少的交换次数**

证明：每次凑成一对，最后剩两对时，一次交换可以凑两对，最少的交换次数就是n-1次

**n对情侣中，有m个环，则至少n-m次交换。**

证明：n对情侣，

m=1，最少n-1次交换

m=2，最少n-2次交换

m=k，最少n-k次交换

m=k+1，每个环内部交换，为n-k-1次交换，若环之间进行交换，将k+1个环，分成1个包含x对情侣的环和包含n-x对情侣的k个环，1个环和k个环中的任意环进行交换都不会凑成情侣，且只会将两个交换的环构成更大的环，那么原来的k+1个环就变成了k个环，最少需要n-k次交换，总计n-k+1次交换。所以只能每个环内部进行交换，可以获得最少的交换次数。

**因此我们可以得到以下两点：**

- n对情侣，m个环，最少的交换次数为n-m次
- 通过每次凑成一对的策略，可以以最少的交换次数把所有情侣凑成对

于是问题变成了如何求得环个数，即连通个数的问题。或者每次凑成一对的交换总个数问题。

**解题思路一**：

广度优先搜索。

**时间复杂度**：$O(N)$。N是情侣对数。

**空间复杂度**：$O(N)$。

```python
class Solution:
    def minSwapsCouples(self, row: List[int]) -> int:
        l = len(row)
        graph = [i for i in range(l)]
        flag = [False for _ in range(l)]
    
        for i in range(0, l, 2):
            graph[row[i]] = row[i+1]
            graph[row[i+1]] = row[i]

        count = 0
        
        for i in range(0, l, 2):
            if not flag[i]:
                q = collections.deque()
                q.append(i)
                while len(q) != 0:
                    top = q[0]
                    flag[top] = True
                    q.popleft()
                    if not flag[graph[top]]:
                        q.append(graph[top])
                    if not flag[top^1]:
                        q.append(top^1)
                count += 1

        return l // 2 - count
```

**解题思路二**：

并查集

**时间复杂度**：$O(NlogN)$。N是情侣对数。

**空间复杂度**：$O(N)$。

```python
class unionFind:
    def __init__(self, n):
        self.root = [i for i in range(n)]
        self.count = n
    def union(self, x, y):
        if self.find(x) != self.find(y):
            self.count -= 1
            self.root[self.find(x)] = self.find(y)
    def find(self, x):
        while self.root[x] != x:
            x = self.root[x]
        return x
    def getCount(self):
        return self.count

class Solution:
    def minSwapsCouples(self, row: List[int]) -> int:
        couples = len(row) // 2
        uf = unionFind(couples)
        for i in range(couples):
            uf.union(row[i*2] // 2, row[i*2+1] // 2)
        return couples - uf.getCount()
```

**解题思路三**：

元素交换。由广度优先搜索建图的思想，我们可以知道，如果每次通过凑成一对的方式进行交换，其实就是在环内操作，从左到右不断凑成对，假设第i个环的对数为Xi，则每次凑成一对，交换Xi-1次就能将环内的所有对凑好。累加所有的环，则总的交换次数为n-m次，n是总的对数，m是环的个数。我们通过数学归纳法证明了n-m是最小的交换次数，所以，模拟元素交换就可以得到最优解。

**时间复杂度**：$O(N)$。N是情侣对数。

**空间复杂度**：$O(N)$。

```python
class Solution:
    def minSwapsCouples(self, row: List[int]) -> int:
        l = len(row)
        pos = [i for i in range(l)]
        for i in range(l):
            pos[row[i]] = i
        count = 0
        for i in range(0, l, 2):
            if row[i]^1 != row[i+1]:
                pos[row[i+1]] = pos[row[i]^1]
                row[pos[row[i]^1]], row[i+1] = row[i+1], row[i]^1 
                count += 1
        return count
```

​	